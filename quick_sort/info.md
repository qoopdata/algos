# Быстрая сортировка <=> Quick Sort

---

## Описание

Получаем на вход неотсортированный массив.
Рекурсивно сортируем массив по возрастанию, разделяя массив по опорному значению из массива на левую часть (элементы которой меньше, чем опорное значение) и правую часть (элементы которой больше, чем опорное значение).

## Принцип работы

Мы получаем массив из чисел в неотсортированном виде. Для того, чтобы отсортировать его по методу быстрой сортировки, нам нужно рекурсивно взять опорное число (к примеру, пусть это будет первое число из полученного массива) и начать сравнивать каждое число из массива с опорным. Если сравниваемое число больше или равно опорному, то мы добавляем его в пустой список под именем "right", так как справа идут числа больше опорного, чтобы отсортировать в возрастающем порядке. Если сравниваемое число меньше опорного, то добавляем его в пустой список под именем "left", так как слева идут числа меньше опорного, чтобы снова отсортировать в возрастающем порядке. Если мы хотим сортировать в убывающем порядке, то нам нужно добавлять меньше числа в "right", а большие в "left", чтобы сильно не менять структуру кода и все равно будет понятно. Теперь, когда мы прошлись по всем числам массива, делаем `return` вида `quick_sort(left) + [pivot] + quick_sort(right)`, где `pivot` - опорное значение.
Таким рекурсивным образом, мы можем отсортировать любой массив данных.
В худшем случае, сложность алгоритма быстрой сортировки составляет `O(N²)`, однако, чаще всего, наш алгоритм работает со сложностью `O(N*logN)` - это происходит потому, что если нам будет дан массив, который при опорном элементе равным первому элементу данного массива, будет давать постоянно пустую "сторону объединения" ("left" или "right"), то алгоритм сортировки будет создавать куда больше рекурсивных вызовов, чем если бы мы взяли значение из середины, которое, возможно бы, не давало постоянно пустого одной из "стороны объединения".
